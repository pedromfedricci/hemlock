use super::{Mutex, MutexNode};
use crate::cfg::thread::LocalKey;
use crate::relax::Relax;

#[cfg(test)]
use crate::test::{LockNew, LockThen, LockWithThen, TryLockThen, TryLockWithThen};

/// A short alias for a static shared reference over a local mutex node.
type Key = &'static LocalMutexNode;

/// Declares a new [`raw::LocalMutexNode`] key, which is a handle to the thread
/// local node of the currently running thread.
///
/// The macro wraps any number of static declarations and make them thread
/// local. Each provided name is associated with a single thread local key. The
/// keys are wrapped and managed by the [`LocalMutexNode`] type, which are the
/// actual handles meant to be used with the `lock_with_local_then` API family
/// from [`raw::Mutex`]. Handles are provided by reference to functions.
///
/// See: [`try_lock_with_local_then`] and [`lock_with_local_then`] for more
/// information.
///
/// The thread local node definition generated by this macro avoids lazy
/// initialization and does not need to be dropped, which enables a more
/// efficient underlying implementation. See [`std::thread_local!`] macro.
///
/// # Sintax
///
/// * Allows multiple static definitions, must be separated with semicolons.
/// * Visibility is optional (private by default).
/// * Requires `static` keyword and a **UPPER_SNAKE_CASE** name.
///
/// # Example
///
/// ```
/// use hemlocker::raw::spins::Mutex;
///
/// // Multiple difenitions.
/// hemlocker::thread_local_node! {
///     pub static NODE;
///     static OTHER_NODE1;
/// }
///
/// // Single definition.
/// hemlocker::thread_local_node!(pub static OTHER_NODE2);
///
/// let mutex = Mutex::new(0);
/// // Keys are provided to APIs by reference.
/// mutex.lock_with_local_then(&NODE, |data| *data = 10);
/// assert_eq!(mutex.lock_with_local_then(&NODE, |data| *data), 10);
/// ```
/// [`raw::Mutex`]: Mutex
/// [`raw::LocalMutexNode`]: LocalMutexNode
/// [`std::thread_local!`]: https://doc.rust-lang.org/std/macro.thread_local.html
/// [`try_lock_with_local_then`]: Mutex::try_lock_with_local_then
/// [`lock_with_local_then`]: Mutex::lock_with_local_then
#[macro_export]
macro_rules! thread_local_node {
    // Empty (base for recursion).
    () => {};
    // Process multiply definitions (recursive).
    ($vis:vis static $node:ident; $($rest:tt)*) => {
        $crate::__thread_local_node_inner!($vis $node, raw);
        $crate::thread_local_node!($($rest)*);
    };
    // Process single declaration.
    ($vis:vis static $node:ident) => {
        $crate::__thread_local_node_inner!($vis $node, raw);
    };
}

// Transparent thread local, mutex node definition used by:
// - `Mutex::try_lock_local_then`
// - `Mutex::lock_local_then`
thread_local_node! { static NODE; }

/// A handle to a [`MutexNode`] stored at the thread local storage.
#[derive(Debug)]
#[repr(transparent)]
pub struct LocalMutexNode {
    #[cfg(not(all(loom, test)))]
    key: LocalKey<MutexNode>,

    // We can't take ownership of Loom's `thread_local!` value since it is a
    // `static`, non-copy value, so we just point to it.
    #[cfg(all(loom, test))]
    key: &'static LocalKey<MutexNode>,
}

#[cfg(not(tarpaulin_include))]
impl LocalMutexNode {
    /// Creates a new `LocalMutexNode` key from the provided thread local node
    /// key.
    #[cfg(not(all(loom, test)))]
    #[doc(hidden)]
    #[must_use]
    #[inline(always)]
    pub const fn __new(key: LocalKey<MutexNode>) -> Self {
        Self { key }
    }

    /// Creates a new Loom based `LocalMutexNode` key from the provided thread
    /// local node key.
    #[cfg(all(loom, test))]
    #[must_use]
    pub const fn new(key: &'static LocalKey<MutexNode>) -> Self {
        Self { key }
    }
}

impl<T: ?Sized, R: Relax> Mutex<T, R> {
    /// Attempts to acquire this mutex and then runs a closure against the
    /// protected data.
    ///
    /// If the lock could not be acquired at this time, then a [`None`] value is
    /// given back as the closure argument. If the lock has been acquired, then
    /// a [`Some`] value with the mutex proteced data is given instead. The lock
    /// will be unlocked when the closure scope ends.
    ///
    /// This function does not block.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use std::thread;
    ///
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// let mutex = Arc::new(Mutex::new(0));
    /// let c_mutex = Arc::clone(&mutex);
    ///
    /// thread::spawn(move || {
    ///     c_mutex.try_lock_local_then(|data| {
    ///         if let Some(data) = data {
    ///             *data = 10;
    ///         } else {
    ///             println!("try_lock_local failed");
    ///         }
    ///     });
    /// })
    /// .join().expect("thread::spawn failed");
    ///
    /// assert_eq!(mutex.lock_local_then(|data| *data), 10);
    /// ```
    ///
    /// Compile fail: borrows of the data cannot escape the given closure:
    ///
    /// ```compile_fail,E0515
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// let mutex = Mutex::new(1);
    /// let borrow = mutex.try_lock_local_then(|data| &*data.unwrap());
    /// ```
    // TODO: Better naming convention? Maybe not making a wrapper at all?
    #[inline]
    pub fn try_lock_local_then<F, Ret>(&self, f: F) -> Ret
    where
        F: FnOnce(Option<&mut T>) -> Ret,
    {
        self.try_lock_with_local_then(&NODE, f)
    }

    /// Attempts to acquire this mutex and then runs a closure against the
    /// protected data.
    ///
    /// If the lock could not be acquired at this time, then a [`None`] value is
    /// given back as the closure argument. If the lock has been acquired, then
    /// a [`Some`] value with the mutex proteced data is given instead. The lock
    /// will be unlocked when the closure scope ends.
    ///
    /// To acquire a Hemlock through this function, it's also required a
    /// queue node, which is a record that keeps a link for forming the queue,
    /// to be stored in the current locking thread local storage. See
    /// [`LocalMutexNode`] and [`thread_local_node!`].
    ///
    /// This function does not block.
    ///
    /// # Panics
    ///
    /// Panics if the key currently has its destructor running, and it **may**
    /// panic if the destructor has previously been run for this thread.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use std::thread;
    ///
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Arc::new(Mutex::new(0));
    /// let c_mutex = Arc::clone(&mutex);
    ///
    /// thread::spawn(move || {
    ///     c_mutex.try_lock_with_local_then(&NODE, |data| {
    ///         if let Some(data) = data {
    ///             *data = 10;
    ///         } else {
    ///             println!("try_lock_with_local_then failed");
    ///         }
    ///     });
    /// })
    /// .join().expect("thread::spawn failed");
    ///
    /// assert_eq!(mutex.lock_with_local_then(&NODE, |data| *data), 10);
    /// ```
    ///
    /// Compile fail: borrows of the data cannot escape the given closure:
    ///
    /// ```compile_fail,E0515
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Mutex::new(1);
    /// let borrow = mutex.try_lock_with_local_then(&NODE, |data| &*data.unwrap());
    /// ```
    #[inline]
    pub fn try_lock_with_local_then<F, Ret>(&self, node: Key, f: F) -> Ret
    where
        F: FnOnce(Option<&mut T>) -> Ret,
    {
        node.key.with(|node| self.try_lock_with_then(node, f))
    }

    /// Acquires this mutex and then runs the closure against the protected data.
    ///
    /// This function will block the local thread until it is available to acquire
    /// the mutex. Upon acquiring the mutex, the user provided closure will be
    /// executed against the mutex protected data. Once the closure goes out of
    /// scope, it will unlock the mutex.
    ///
    /// This function will block if the lock is unavailable.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use std::thread;
    ///
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// let mutex = Arc::new(Mutex::new(0));
    /// let c_mutex = Arc::clone(&mutex);
    ///
    /// thread::spawn(move || {
    ///     c_mutex.lock_local_then(|data| *data = 10);
    /// })
    /// .join().expect("thread::spawn failed");
    ///
    /// assert_eq!(mutex.lock_local_then(|data| *data), 10);
    /// ```
    ///
    /// Compile fail: borrows of the data cannot escape the given closure:
    ///
    /// ```compile_fail,E0515
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// let mutex = Mutex::new(1);
    /// let borrow = mutex.lock_local_then(|data| &*data);
    /// ```
    #[inline]
    // TODO: Better naming convention? Maybe not making a wrapper at all?
    pub fn lock_local_then<F, Ret>(&self, f: F) -> Ret
    where
        F: FnOnce(&mut T) -> Ret,
    {
        self.lock_with_local_then(&NODE, f)
    }

    /// Acquires this mutex and then runs the closure against the protected data.
    ///
    /// This function will block the local thread until it is available to acquire
    /// the mutex. Upon acquiring the mutex, the user provided closure will be
    /// executed against the mutex protected data. Once the closure goes out of
    /// scope, it will unlock the mutex.
    ///
    /// To acquire a Hemlock through this function, it's also required a
    /// queue node, which is a record that keeps a link for forming the queue,
    /// to be stored in the current locking thread local storage. See
    /// [`LocalMutexNode`] and [`thread_local_node!`].
    ///
    /// This function will block if the lock is unavailable.
    ///
    /// # Panics
    ///
    /// Panics if the key currently has its destructor running, and it **may**
    /// panic if the destructor has previously been run for this thread.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::sync::Arc;
    /// use std::thread;
    ///
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Arc::new(Mutex::new(0));
    /// let c_mutex = Arc::clone(&mutex);
    ///
    /// thread::spawn(move || {
    ///     c_mutex.lock_with_local_then(&NODE, |data| *data = 10);
    /// })
    /// .join().expect("thread::spawn failed");
    ///
    /// assert_eq!(mutex.lock_with_local_then(&NODE, |data| *data), 10);
    /// ```
    ///
    /// Compile fail: borrows of the data cannot escape the given closure:
    ///
    /// ```compile_fail,E0515
    /// use hemlocker::raw::spins::Mutex;
    ///
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Mutex::new(1);
    /// let borrow = mutex.lock_with_local_then(&NODE, |data| &*data);
    /// ```
    #[inline]
    pub fn lock_with_local_then<F, Ret>(&self, node: Key, f: F) -> Ret
    where
        F: FnOnce(&mut T) -> Ret,
    {
        node.key.with(|node| self.lock_with_then(node, f))
    }

    /// Mutable borrows must not escape the closure.
    ///
    /// ```compile_fail
    /// use hemlocker::raw::spins::Mutex;
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Mutex::new(1);
    /// let borrow = mutex.lock_with_local_then(&NODE, |data| data);
    /// ```
    ///
    /// ```compile_fail,E0521
    /// use std::thread;
    /// use hemlocker::raw::spins::Mutex;
    /// hemlocker::thread_local_node!(static NODE);
    ///
    /// let mutex = Mutex::new(1);
    /// mutex.lock_with_local_then(&NODE, |data| {
    ///     thread::spawn(move || {
    ///         let data = data;
    ///     });
    /// });
    /// ```
    #[cfg(doctest)]
    #[cfg(not(tarpaulin_include))]
    const fn __borrows_must_not_escape_closure() {}
}

/// A Mutex wrapper type that calls `lock_local_then` and
/// `try_lock_local_then` when implementing testing traits.
#[cfg(test)]
struct MutexWithLocal<T: ?Sized, R>(Mutex<T, R>);

#[cfg(test)]
impl<T: ?Sized, R> LockNew for MutexWithLocal<T, R> {
    type Target = T;

    fn new(value: Self::Target) -> Self
    where
        Self::Target: Sized,
    {
        Self(Mutex::new(value))
    }
}

#[cfg(test)]
impl<T: ?Sized, R: Relax> LockWithThen for MutexWithLocal<T, R> {
    // A thread local node is transparently accessed instead.
    type Node = ();

    type Guard<'a>
        = &'a mut Self::Target
    where
        Self: 'a,
        Self::Target: 'a;

    fn lock_with_then<F, Ret>(&self, (): &mut Self::Node, f: F) -> Ret
    where
        F: FnOnce(&mut Self::Target) -> Ret,
    {
        self.0.lock_local_then(f)
    }
}

#[cfg(test)]
impl<T: ?Sized, R: Relax> TryLockWithThen for MutexWithLocal<T, R> {
    fn try_lock_with_then<F, Ret>(&self, (): &mut Self::Node, f: F) -> Ret
    where
        F: FnOnce(Option<&mut Self::Target>) -> Ret,
    {
        self.0.try_lock_local_then(f)
    }

    fn is_locked(&self) -> bool {
        self.0.is_locked()
    }
}

#[cfg(test)]
impl<T: ?Sized, R: Relax> LockThen for MutexWithLocal<T, R> {}

#[cfg(test)]
impl<T: ?Sized, R: Relax> TryLockThen for MutexWithLocal<T, R> {}

#[cfg(all(not(loom), test))]
mod test {
    use crate::relax::Yield;
    use crate::test::tests;

    type Mutex<T> = super::MutexWithLocal<T, Yield>;

    #[test]
    fn lots_and_lots_lock() {
        tests::lots_and_lots_lock::<Mutex<_>>();
    }

    #[test]
    fn lots_and_lots_try_lock() {
        tests::lots_and_lots_try_lock::<Mutex<_>>();
    }

    #[test]
    fn lots_and_lots_mixed_lock() {
        tests::lots_and_lots_mixed_lock::<Mutex<_>>();
    }

    #[test]
    fn smoke() {
        tests::smoke::<Mutex<_>>();
    }

    #[test]
    fn test_try_lock() {
        tests::test_try_lock::<Mutex<_>>();
    }

    #[test]
    fn test_lock_arc_nested() {
        tests::test_lock_arc_nested::<Mutex<_>, Mutex<_>>();
    }

    #[test]
    fn test_acquire_more_than_one_lock() {
        tests::test_acquire_more_than_one_lock::<Mutex<_>>();
    }

    #[test]
    fn test_lock_arc_access_in_unwind() {
        tests::test_lock_arc_access_in_unwind::<Mutex<_>>();
    }

    #[test]
    fn test_lock_unsized() {
        tests::test_lock_unsized::<Mutex<_>>();
    }
}

#[cfg(all(loom, test))]
mod model {
    use crate::loom::models;
    use crate::relax::Yield;

    type Mutex<T> = super::MutexWithLocal<T, Yield>;

    #[test]
    fn try_lock_join() {
        models::try_lock_join::<Mutex<_>>();
    }

    #[test]
    fn lock_join() {
        models::lock_join::<Mutex<_>>();
    }

    #[test]
    fn mixed_lock_join() {
        models::mixed_lock_join::<Mutex<_>>();
    }
}
